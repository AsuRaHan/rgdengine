//////////////////////////////////////////////////////////////////////////
// @author Sidorenko "PC" Alexander
// @date 01.07.2006
// email: sidorenko.alexander@gmail.com
// project: RGDE
// description: 
// example of use:
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Technique.h"
#include "Generator.h"
#include <sstream>

CTechnique::CTechnique(const Combination& combination)
{
	reset();

	for(size_t i = 0; i < combination.size(); i++)
	{
		addName(combination[i].getVariation().getNameAdd());
		const CVariation::PinPasses& variationPinPasses = combination[i].getVariation().getPinPasses();
		for(size_t i = 0; i < variationPinPasses.size(); i++)
		{
			const CPinPass& pinPass = variationPinPasses[i];

			std::string pinPassType = pinPass.getType();

			if(pinPassType == "current")
				pinPass.setup();
			else
			if(pinPassType == "new_copy_from_prev")
			{
				endPass(getCurrentPass());
				addNewPass(getCurrentPass());
				pinPass.setup();
			}
			else
			if(pinPassType == "new_copy_from_all_prev")
			{
				endPass(getCurrentPass());
				for(size_t i = 0; i < m_passes.size(); i++)
				{
					setCurrentPass(uint(i));
					addNewPass(getCurrentPass());
					pinPass.setup();
					if(i != m_passes.size() - 1)
						endPass(getCurrentPass());
				}
			}
			else
				base::lwrn<<"PinPass has unknown type \""<<pinPassType<<"\". Skipping...";
		}
	}

	endPass(getCurrentPass());
}

CTechnique::~CTechnique()
{
}

std::string CTechnique::getName() const
{
	std::string result;
	for(size_t i = 0; i < m_nameAdds.size(); i++)
		result += m_nameAdds[i];
	if(result != "")
		return result;
	else
		return "Default";
}

std::string CTechnique::getText() const
{
	std::ostringstream stream;

	stream<<"/********************************************************\n"<<
			" * This technique is generated by RGDE EffectGenerator. *\n"<<
			" * (c) RGDE Team. 2006.                                 *\n"<<
			" ********************************************************/\n";
	stream<<"technique "<<getName()<<"\n{\n";
	for(size_t i = 0; i < m_passes.size(); i++)
	{
		stream<<"   pass pass"<<i<<"\n   {\n";
		stream<<m_passes[i].getText();
		stream<<"   }\n";
	}
	stream<<"}";

	return stream.str();
}

void CTechnique::setCurrentPass(uint n)
{
	if(size_t(n) < m_passes.size())
		m_currentPass = n;
}

CPass& CTechnique::getCurrentPass()
{
	return m_passes[m_currentPass];
}

CPass& CTechnique::addNewPass(const CPass& pass)
{
	m_passes.push_back(CPass(pass));
	setCurrentPass(uint(m_passes.size() - 1));
	return getCurrentPass();
}

CPass& CTechnique::addNewPass()
{
	return addNewPass(CPass());
}

void CTechnique::addName(const std::string& nameAdd)
{
	m_nameAdds.push_back(nameAdd);
	std::sort(m_nameAdds.begin(), m_nameAdds.end(), std::less<std::string>());
}

void CTechnique::reset()
{
	m_nameAdds.clear();
	m_passes.clear();
	setCurrentPass(0);
	addNewPass();
	beginPass();
}

void CTechnique::beginPass() const
{
	const CGenerator::States& states = TheGenerator::Get().getStates();

	for(size_t i = 0; i < states.size(); i++)
		states[i]->beginNewPass();
}

void CTechnique::endPass(CPass& pass) const
{
	const CGenerator::States& states = TheGenerator::Get().getStates();

	for(size_t i = 0; i < states.size(); i++)
		states[i]->endPass(pass);
}